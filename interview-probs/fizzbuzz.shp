# we'll need recursion, so define some combinators
U = \f.(f f)
Y = (U \h.\f.(f \x.(((h h) f) x)))
void = \x.(U U)

# we need numbers, so define some numbers
0 = \f.\x.x
succ = \n.\f.\x.(f (n f x))
1 = (succ 0)
+ = \m.\n.\f.\x.((m succ n) f x)
* = \m.\n.\x.(m (n x))

# we'll need booleans
true = \t.\f.t
false = \t.\f.f

# and some logic helpers
not = \p.\t.\f.(p f t)
if = \p.\a.\b.((p a b) void)

# we'll need pairs
make-pair = \x.\y. \t.(t x y)
first = \p.(p true)
second = \p.(p false)

# we'll need to do multiple things since printing is side-effecting
do2 = \a.\b.b
do4 = \a.\b.\c.\d.d

# we'll need lists
nil = (make-pair false void)
nil? = \l. (not (first l))
cons = \a.\b.(make-pair true (make-pair a b))
car = \l. (first (second l))
cdr = \l. (second (second l))

# let's define some hex digit nibbles
x0 = 0
x1 = (succ x0)  x2 = (succ x1)  x3 = (succ x2)  x4 = (succ x3)  x5 = (succ x4)
x6 = (succ x5)  x7 = (succ x6)  x8 = (succ x7)  x9 = (succ x8)  xA = (succ x9)
xB = (succ xA)  xC = (succ xB)  xD = (succ xC)  xE = (succ xD)  xF = (succ xE)
x10 = (succ xF)

# let's make a function that can create bytes from nibbles using the builtins
make-byte = \x.\y. (+ (* x x10) y)
print-byte = \n. (BYTE_PRINT (n BYTE_NEXT BYTE_NULL))

# list printing
print-list = (Y \print-list.\l.
  (if (nil? l)
      \_. nil
      \_. (do2 (print-byte (car l))
               (print-list (cdr l)))))
print-newline = \_. (print-byte (make-byte x0 xA))

# list reversing
reverse-list = \l.(
  (Y \recurse. \old.\new.
    (if (nil? old)
        \_.new
        \_.(recurse (cdr old) (cons (car old) new))))
  l nil)

# predicate
pred = \n.(
  (\n.\f.\x. (second (n
    \p.(make-pair (f (first p)) (first p))
    (make-pair x x))) n)
  succ 0)

always-false = \_.false
zero? = \n.(n always-false true)

and = \a.\b.(a b false)
or = \a.\b.(a true b)

- = \m.\n.(n pred m)
eq? = \m.\n.(and (zero? (- m n)) (zero? (- n m)))

/ = (Y \/.\m.\n.
  (if (eq? m n)
      \_. 1
      \_. (if (zero? (- m n))
          \_. 0
          \_. (+ 1 (/ (- m n) n)))))

% = \m.\n. (- m (* (/ m n) n))

zero-digit = (make-byte x3 x0)
10 = (succ (succ (succ (succ (succ (succ (succ (succ (succ 1)))))))))

itoa = \n.(
  (Y \recurse.\n.\result.
    (if (zero? n)
        \_. (if (nil? result)
               \_. (cons zero-digit nil)
               \_. result)
        \_. (recurse (/ n 10) (cons (+ (* x3 x10) (% n 10)) result))))
  n nil)

fizzmsg = (cons (make-byte x4 x6)
          (cons (make-byte x6 x9)
          (cons (make-byte x7 xA)
          (cons (make-byte x7 xA) nil))))
buzzmsg = (cons (make-byte x4 x2)
          (cons (make-byte x7 x5)
          (cons (make-byte x7 xA)
          (cons (make-byte x7 xA) nil))))
fizzbuzzmsg = (cons (make-byte x4 x6)
          (cons (make-byte x6 x9)
          (cons (make-byte x7 xA)
          (cons (make-byte x7 xA)
          (cons (make-byte x6 x2)
          (cons (make-byte x7 x5)
          (cons (make-byte x7 xA)
          (cons (make-byte x7 xA) nil))))))))

for = \n.\f.(
  (Y \recurse.\remaining.\current.\f.
    (if (zero? remaining)
        \_. nil
        \_. (do2 (f current)
                 (recurse (pred remaining) (succ current) f))))
  n 0 f)

3 = (succ (succ (succ 0)))
5 = (succ (succ 3))

fizzbuzz = \n.
  (for n \i.
    (do2
      (if (zero? (% i 3))
          \_. (if (zero? (% i 5))
                  \_. (print-list fizzbuzzmsg)
                  \_. (print-list fizzmsg))
          \_. (if (zero? (% i 5))
                  \_. (print-list buzzmsg)
                  \_. (print-list (itoa i))))
      (print-newline nil)))

(fizzbuzz (+ (* 10 10) 1))
